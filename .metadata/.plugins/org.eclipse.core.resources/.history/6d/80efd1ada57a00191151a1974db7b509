package org.xxjr.mq.listener.receiver;

import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.LinkedBlockingQueue;

import javax.annotation.PreDestroy;

import org.ddq.active.mq.XxjrMqSendUtil;
import org.ddq.common.constant.DuoduoConstant;
import org.ddq.common.context.AppParam;
import org.ddq.common.context.AppProperties;
import org.ddq.common.context.AppResult;
import org.ddq.common.core.service.RemoteInvoke;
import org.ddq.common.util.DateUtil;
import org.ddq.common.util.LogerUtil;
import org.ddq.common.util.StringUtil;
import org.llw.mq.rabbitmq.RabbitMqConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.xxjr.busi.util.push.PushList;
import org.xxjr.busi.util.push.PushPlatformUtils;
import org.xxjr.busi.util.push.PushUtil;
import org.xxjr.busi.util.push.ThirdDataCount;
import org.xxjr.mq.listener.consumer.RabbitMqConsumer;
import org.xxjr.mq.listener.util.XxjrInitAnnotation;
import org.xxjr.sys.util.NumberUtil;
import org.xxjr.sys.util.ServiceKey;
import org.xxjr.sys.util.SysParamsUtil;

@Component
@XxjrInitAnnotation(beanName="pushDataReceiver",initMethod="init")
public class PushDataReceiver extends RabbitMqConsumer{
	
	@Autowired
	private RabbitMqConfig rabbitMqConfig;
	
	@Value("${rabbit.queue.pushData}")
	private String queueName;
	
	private static final Integer immediate = 1;
	
	public void onMessage(Map<String, Object> messageInfo) {
		try {
			LogerUtil.log("PushDataReceiver onMessage messageInfo:" + messageInfo);
			
			LogerUtil.log("PushDataReceiver local Thread name" + Thread.currentThread().getName());
			
			int pushCfgQuerySize = SysParamsUtil.getIntParamByKey("pushCfgQuerySize", 100);
			
			int type = NumberUtil.getInt(messageInfo.get("type"), -1);
			int isAllot = NumberUtil.getInt(messageInfo.get("isAllot"), 0);
			String sourceTypes = SysParamsUtil.getStringParamByKey("third_push_sourceTypes", "insurancePushPoolService:0");
			if (PushPlatformUtils.TYPE_INSURE == type) {
				for (String souceType : sourceTypes.split(",")) {
					String[] split = souceType.split(":");
					pushInsure(pushCfgQuerySize, split[0], split[1]);//保险渠道数据推送
				}
			}else if (PushPlatformUtils.TYPE_LOAN == type && isAllot == 0) {
				pushLoan(pushCfgQuerySize);//贷款渠道数据推送
			}else if (PushPlatformUtils.TYPE_LOAN == type && isAllot == 1) {
				pushAllotLoan();
			}else if (type == 4) {//微信朋友圈统计,接口需要白名单，mq-listener的地址固定
				ThirdDataCount.wxConvertor(messageInfo);
			}
		} catch (Exception e) {
			LogerUtil.error(PushDataReceiver.class, e, "PushDataReceiver mq execute error!");
			XxjrMqSendUtil.saveFailureLog("PushDataReceiver", messageInfo);
		}
	}
	
	
	private static void pushLoan(int size) {
		if (!isStartPushTime(PushPlatformUtils.TYPE_LOAN)) {
			return;
		}
		
		int startDay = SysParamsUtil.getIntParamByKey("third_push_queryParam_day", 0);
		String startDate = DateUtil.toStringByParttern(DateUtil.getNextDay(new Date(), startDay), DateUtil.DATE_PATTERN_YYYY_MM_DD);
		String endDate = startDate + " 23:59:59";
		AppParam queryParam = new AppParam("thirdPushPoolService", "queryPushData");
		queryParam.setRmiServiceName(AppProperties.getProperties(DuoduoConstant.RMI_SERVICE_START + ServiceKey.Key_busi_in));
		queryParam.addAttr("startCreateTime", startDate);//只查询当天入池的数据
		queryParam.addAttr("endCreateTime", endDate);
		queryParam.addAttr("immediate", immediate);
		queryParam.addAttr("size", size);
		AppResult result = RemoteInvoke.getInstance().call(queryParam);
		
		LogerUtil.log("pushLoan data rows size:" + result.getRows().size());
		
		if (result.getRows().size() > 0) {//没有数据
			List<Map<String, Object>> loanList = result.getRows();//待推送数据
			
			//需要推送的渠道
			List<Map<String, Object>> loanChannel = PushPlatformUtils.getOpenChannelList(PushPlatformUtils.TYPE_LOAN, false, false);
			if (loanChannel.size() > 0) {//没有打开的渠道
				LogerUtil.log("pushLoan open channel size:" + loanChannel.size());

				//渠道队列
				LinkedBlockingQueue<Map<String, Object>> loanQueue = new LinkedBlockingQueue<Map<String,Object>>(loanChannel);
				
				List<Map<String, Object>> errList = new ArrayList<Map<String,Object>>();//第一次推送失败数据
				Map<String, Object> errorInfo = new HashMap<String, Object>();//第一次循环数据推送失败或未通过限制的信息
				//------------------------>贷款推送
				
				//存在少量可能重复的数据
				if (SysParamsUtil.getBoleanByKey("push_data_cfg_isDistinct", true)) {
					PushPlatformUtils.distinctByKey(loanList, "applyId", PushPlatformUtils.TYPE_LOAN, -1);
				}
				
				for (Map<String, Object> map : loanList) {
					Map<String, Object> channel = loanQueue.poll();//获取渠道
					if (channel == null) {//如果队列为空继续补充
						loanQueue.addAll(loanChannel);
						channel = loanQueue.poll();
					}
					int pushType = NumberUtil.getInt(channel.get("pushCode"));
					PushUtil pushLoan = PushList.getPushByCode(pushType);
					int status = 0;// 1 成功 2推送失败 3渠道已关闭或日推送数量到上限  4推送配置限制
					if (pushLoan != null) {
						status = pushLoan.pushData(map, pushType);
					}
					
					if (status == 5) {//代表渠道暂停了需要把推送的数据修改到暂停结束的时间再进行推送
						updateStopData(pushType, map.get("pushId"));
						continue;
					}
					//是否需要复用
					saveThirdPool(status, channel, map);
					
					if ((status == 2 || status ==4)) {//失败或条件未通过，放入失败列表
						errorInfo.put(pushType + "-" + StringUtil.getString(map.get("pushId")), "true");
						errList.add(map);
					}
				}
				
				for (Map<String, Object> map : errList) {//循环失败列表，把失败的数据在每个渠道推送一遍（除了第一次循环失败的渠道）
					
					loanQueue.clear();//这里是推送失败的数据不需要考虑均分，推送所有的渠道成功即可,所以要每个渠道推送一遍
					loanQueue.addAll(loanChannel);
					
					Map<String, Object> channel = loanQueue.poll();
					while (channel != null) {
						int pushType = NumberUtil.getInt(channel.get("pushCode"));
						PushUtil pushLoan = PushList.getPushByCode(pushType);
						int status = 2;
						
						if (pushLoan != null && StringUtils.isEmpty(errorInfo.get(pushType + "-" + StringUtil.getString(map.get("pushId"))))) {
							//这里的另外一个条件是排除推送数据第一次循环推送或条件未通过的渠道
							status = pushLoan.pushData(map, pushType);
						}
						
						if (status == 1) {//成功进入下一次循环
							break;
						}
						
						if (status == 5) {//代表渠道暂停了需要把推送的数据修改到暂停结束的时间再进行推送
							updateStopData(pushType, map.get("pushId"));
							break;
						}
						
						if (status == 2 || status == 4 || status == 3) {//失败了，并且是队列中的最后一个渠道删除并进入下一次循环
							channel = loanQueue.poll();
							if (channel == null) {
								PushPlatformUtils.delete(map.get("pushId"), PushPlatformUtils.TYPE_LOAN, -1);
								break;
							}
						}
					}
				}
			}
		}
		execReusePush(size, startDate, endDate);//复用的数据进行推送，每次的数量为正常推送的一半
		
		execDelayPush(size);
	}
	
	private static void pushInsure(int size, String serviceName, String sourceType) {
		if (!isStartPushTime(PushPlatformUtils.TYPE_INSURE)) {
			return;
		}
		
		//---------------------------->保险推送
		List<Map<String, Object>> insureChannel = PushPlatformUtils.getInsureBySourceType(sourceType);
		LinkedBlockingQueue<Map<String, Object>> insureQueue = new LinkedBlockingQueue<Map<String,Object>>(insureChannel);
		if (insureChannel.size() <= 0) {
			return;
		}
		int startDay = SysParamsUtil.getIntParamByKey((serviceName + "insure_push_queryParam_day" + sourceType), -3);
		String startDate = DateUtil.toStringByParttern(DateUtil.getNextDay(new Date(), startDay), DateUtil.DATE_PATTERN_YYYY_MM_DD);
		String endDate = startDate + " 23:59:59";
		AppParam queryParam = new AppParam();
		queryParam.setService(serviceName);
		queryParam.setMethod("queryPushData");
		queryParam.setRmiServiceName(AppProperties.getProperties(DuoduoConstant.RMI_SERVICE_START + ServiceKey.Key_busi_in));
		queryParam.addAttr("startDate", startDate);
		queryParam.addAttr("endDate", endDate);
		queryParam.addAttr("size", size);
		queryParam.addAttr("sourceType", sourceType);
		
		AppResult result = RemoteInvoke.getInstance().callNoTx(queryParam);
		List<Map<String, Object>> insureList = result.getRows();
		if (insureList.size() <= 0) {
			return;
		}
		List<Map<String, Object>> errList = new ArrayList<Map<String,Object>>();//失败数据列表
		Map<String, Object> errorInfo = new HashMap<String, Object>();//失败信息
		for (Map<String, Object> map : insureList) {
			Map<String, Object> channel = insureQueue.poll();
			if (channel == null) {//如果队列为空继续补充
				insureQueue.addAll(insureChannel);
				channel = insureQueue.poll();
			}
			int pushType = NumberUtil.getInt(channel.get("pushCode"));
			PushUtil pushLoan = PushList.getPushByCode(pushType);
			int status = 0;
			if (pushLoan != null) {
				status = pushLoan.pushData(map, pushType);
			}
			if (status == 2 || status == 4) {//如果是推送失败或限制条件未过，放入失败集合
				errorInfo.put(pushType + "-" + StringUtil.getString(map.get("pushId")), "true");
				errList.add(map);
			}
		}
		
		for (Map<String, Object> map : errList) {
			
			insureQueue.clear();//这里是推送失败的数据不需要考虑均分，推送所有的渠道成功即可,所以要每个渠道推送一遍
			insureQueue.addAll(insureChannel);
			
			Map<String, Object> channel = insureQueue.poll();
			
			while (channel != null) {
				int pushType = NumberUtil.getInt(channel.get("pushCode"));
				PushUtil pushLoan = PushList.getPushByCode(pushType);
				int status = 2;//和上面
				if (pushLoan != null && StringUtils.isEmpty(errorInfo.get(pushType + "-" + StringUtil.getString(map.get("pushId"))))) {
					//这里的另外一个条件是排除推送数据第一次循环推送或条件未通过的渠道
					status = pushLoan.pushData(map, pushType);
				}
				if (status == 1) {
					break;
				}
				if (status == 2 || status == 4 || status == 3) {
					channel = insureQueue.poll();
					if (channel == null) {
						PushPlatformUtils.delete(map.get("pushId"), PushPlatformUtils.TYPE_INSURE, NumberUtil.getInt(map.get("sourceType"), -1));
						break;
					}
				}
			}
		}
		
		pushInsureFailData(serviceName,sourceType);
	}
	
	
	/**
	 * 推送参与分单的小贷数据
	 */
	private static void pushAllotLoan () {
		
		int startDay = SysParamsUtil.getIntParamByKey("third_push_queryParam_day", 0);
		String startDate = DateUtil.toStringByParttern(DateUtil.getNextDay(new Date(), startDay), DateUtil.DATE_PATTERN_YYYY_MM_DD);
		String endDate = startDate + " 23:59:59";
		
		List<Map<String, Object>> channels = PushPlatformUtils.getOpenChannelList(PushPlatformUtils.TYPE_LOAN, false, true);
		if (channels.size() == 0) {
			return;
		}
		Integer size = PushPlatformUtils.getAvgCount(channels);
		
		AppParam queryParam = new AppParam("thirdPushPoolService", "queryPushData");
		queryParam.setRmiServiceName(AppProperties.getProperties(DuoduoConstant.RMI_SERVICE_START + ServiceKey.Key_busi_in));
		queryParam.addAttr("startCreateTime", startDate);//只查询当天入池的数据
		queryParam.addAttr("endCreateTime", endDate);
		queryParam.addAttr("immediate", 4);
		queryParam.addAttr("size", size);
		AppResult result = RemoteInvoke.getInstance().call(queryParam);
		if (result.getRows().size() > 0) {
			SysParamsUtil.refreshValue(PushPlatformUtils.THIR_ALLOT_PUSH_START, "true");//进行推送处理时先不进入数据
			
			
			List<Map<String, Object>> loanList = result.getRows();
			
			LogerUtil.log("pushLoan open allot channel size:" + channels.size());

			//渠道队列
			LinkedBlockingQueue<Map<String, Object>> loanQueue = new LinkedBlockingQueue<Map<String,Object>>(channels);
			
			List<Map<String, Object>> errList = new ArrayList<Map<String,Object>>();//第一次推送失败数据
			Map<String, Object> errorInfo = new HashMap<String, Object>();//第一次循环数据推送失败或未通过限制的信息
			
			for (Map<String, Object> loanInfo : loanList) {
				Map<String, Object> channel = loanQueue.poll();
				if (channel == null) {//如果队列为空继续补充
					loanQueue.addAll(channels);
					channel = loanQueue.poll();
				}
				int pushType = NumberUtil.getInt(channel.get("pushCode"));
				PushUtil pushLoan = PushList.getPushByCode(pushType);
				int status = 0;// 1 成功 2推送失败 3渠道已关闭或日推送数量到上限  4推送配置限制
				if (pushLoan != null) {
					status = pushLoan.pushData(loanInfo, pushType);
				}
				
				if ((status == 2 || status == 3 || status ==4)) {//失败或条件未通过，放入失败列表
					errorInfo.put(pushType + "-" + StringUtil.getString(loanInfo.get("pushId")), "true");
					errList.add(loanInfo);
				}
			}
			
			for (Map<String, Object> map : errList) {//循环失败列表，把失败的数据在每个渠道推送一遍（除了第一次循环失败的渠道）
				
				loanQueue.clear();//这里是推送失败的数据不需要考虑均分，推送所有的渠道成功即可,所以要每个渠道推送一遍
				loanQueue.addAll(channels);
				
				Map<String, Object> channel = loanQueue.poll();
				while (channel != null) {
					int pushType = NumberUtil.getInt(channel.get("pushCode"));
					PushUtil pushLoan = PushList.getPushByCode(pushType);
					int status = 2;
					
					if (pushLoan != null && StringUtils.isEmpty(errorInfo.get(pushType + "-" + StringUtil.getString(map.get("pushId"))))) {
						//这里的另外一个条件是排除推送数据第一次循环推送或条件未通过的渠道
						status = pushLoan.pushData(map, pushType);
					}
					
					if (status == 1) {//成功进入下一次循环
						break;
					}
					
					if (status == 2 || status == 4 || status == 3) {//失败了，并且是队列中的最后一个渠道删除并进入下一次循环
						channel = loanQueue.poll();
						if (channel == null) {
							PushPlatformUtils.delete(map.get("pushId"), PushPlatformUtils.TYPE_LOAN, -1);
						
							AppParam applyParam = new AppParam("applyService", "thirdFailReApply");
							applyParam.setRmiServiceName(AppProperties.getProperties(DuoduoConstant.RMI_SERVICE_START + ServiceKey.Key_busi_in));
							applyParam.addAttr("applyId", map.get("applyId"));
							applyParam.addAttr("telephone", map.get("telephone"));
							RemoteInvoke.getInstance().call(applyParam);
							break;
						}
					}
				}
			}
			
			SysParamsUtil.refreshValue(PushPlatformUtils.THIR_ALLOT_PUSH_START, "false");
		}
		
		execDelayPush(size);
	}
	
	/**
	 * 复用数据
	 * @param pushType
	 * @param delayDay
	 * @param row
	 */
	private static boolean saveThirdPool (Integer status, Map<String, Object> channel, Map<String, Object> data) {
		if (status != 1 || StringUtils.isEmpty(channel.get("reuse"))) {//需要推送的渠道限制条件过了并且有需要复用的渠道
			return false;
		}
		String reuse = StringUtil.getString(channel.get("reuse"));
		String[] pushCodes = reuse.split(",");
		Integer delayDay = NumberUtil.getInt(channel.get("delayDay"), 0);
		Date createTime = DateUtil.getNextDay(new Date(), delayDay);
		for (String pushCode : pushCodes) {
			AppParam updateParam = new AppParam("thirdPushPoolService", "insert");
			updateParam.setRmiServiceName(AppProperties.getProperties(DuoduoConstant.RMI_SERVICE_START + ServiceKey.Key_busi_in));
			updateParam.addAttr("createTime", createTime);
			updateParam.addAttr("immediate", 3);
			updateParam.addAttr("pushType", pushCode);
			updateParam.addAttr("applyTime", data.get("applyTime"));
			updateParam.addAttr("applyId", data.get("applyId"));
			RemoteInvoke.getInstance().call(updateParam);
		}
		return true;
	}
	
	/**
	 * 把推送数据的推送时间修改为暂停时间之后，并是针对每一个渠道单独推送
	 */
	private static void updateStopData (Integer pushType, Object pushId) {
		try {
			Map<String, Object> channel = PushPlatformUtils.getConfigByCode(pushType);
			
			AppParam param = new AppParam("thirdPushPoolService", "update");
			param.setRmiServiceName(AppProperties.getProperties(DuoduoConstant.RMI_SERVICE_START + ServiceKey.Key_busi_in));
			param.addAttr("createTime", channel.get("stopEndDate"));
			param.addAttr("immediate", 3);
			param.addAttr("pushType", pushType);
			param.addAttr("pushId", pushId);
			RemoteInvoke.getInstance().call(param);
		} catch (Exception e) {
			LogerUtil.error(PushDataReceiver.class, e, "push rmi queue error");
		}
	}
	
	public static void execReusePush (int size, String startDate, String endDate) {
		size = size / 2;
		AppParam queryParam = new AppParam("thirdPushPoolService", "queryPushData");
		queryParam.setRmiServiceName(AppProperties.getProperties(DuoduoConstant.RMI_SERVICE_START + ServiceKey.Key_busi_in));
		queryParam.addAttr("size", size);
		queryParam.addAttr("immediate", 3);
		queryParam.addAttr("startCreateTime", startDate);//只查询当天入池的数据
		queryParam.addAttr("endCreateTime", endDate);
		AppResult queryResult = RemoteInvoke.getInstance().callNoTx(queryParam);
		List<Map<String, Object>> rows = queryResult.getRows();
		PushPlatformUtils.distinctByKey(rows, "applyId", PushPlatformUtils.TYPE_LOAN, -1);
		for (Map<String, Object> data : rows) {
			Integer pushType = NumberUtil.getInt(data.get("pushType"), -1);
			PushUtil push = PushList.getPushByCode(pushType);
			if (push != null) {
				int status = push.pushData(data, pushType);
				if (status != 1) {
					PushPlatformUtils.delete(data.get("pushId"), PushPlatformUtils.TYPE_LOAN, -1);
				}
			}
		}
	}
	
	public static void execDelayPush (int size) {
		List<Map<String, Object>> channels = PushPlatformUtils.getOpenChannelList(PushPlatformUtils.TYPE_LOAN, true, false);
		if (channels.size() == 0) {
			return;
		}
		int channelSize = (PushPlatformUtils.getOpenChannelList(PushPlatformUtils.TYPE_LOAN, false, false).size() + channels.size());
		size = (size / channelSize);
		for (Map<String, Object> map : channels) {
			int pushType = NumberUtil.getInt(map.get("pushCode"));
			int startDay = NumberUtil.getInt(map.get("startDay"), -1);
			int endDay = NumberUtil.getInt(map.get("endDay"), -1);
			if (endDay == -1) {
				continue;
			}
			

			String endDateStr = DateUtil.toStringByParttern(DateUtil.getNextDay(new Date(), -endDay),DateUtil.DATE_PATTERN_YYYY_MM_DD);
			endDateStr = endDateStr + " 23:59:59";
			
			AppParam queryParam = new AppParam("thirdPushPoolService", "queryPushData");
			queryParam.setRmiServiceName(AppProperties.getProperties(DuoduoConstant.RMI_SERVICE_START + ServiceKey.Key_busi_in));
			queryParam.addAttr("size", size);
			queryParam.addAttr("immediate", 1);
			if (startDay > -1) {//延迟开始时间可以不需要
				String startDateStr = DateUtil.toStringByParttern(DateUtil.getNextDay(new Date(), -startDay),DateUtil.DATE_PATTERN_YYYY_MM_DD);
				queryParam.addAttr("startCreateTime", startDateStr);
			}
			queryParam.addAttr("endCreateTime", endDateStr);
			AppResult queryResult = RemoteInvoke.getInstance().callNoTx(queryParam);
			
			List<Map<String, Object>> rows = queryResult.getRows();
			PushPlatformUtils.distinctByKey(rows, "applyId", PushPlatformUtils.TYPE_LOAN, -1);
			
			for (Map<String, Object> data : rows) {
				PushUtil push = PushList.getPushByCode(pushType);
				if (push != null) {
					int status = push.pushData(data, pushType);
					if (status != 1) {
						PushPlatformUtils.delete(data.get("pushId"), PushPlatformUtils.TYPE_LOAN, -1);
					}
				}
			}
		}
	}
	
	
	public static void pushInsureFailData(String serviceName, String sourceType){
		if (!sourceType.equals("0")) {
			return;
		}
		int size = SysParamsUtil.getIntParamByKey("failDataSize", 100);
		String startDate = DateUtil.toStringByParttern(new Date(), DateUtil.DATE_PATTERN_YYYY_MM_DD);
		String endDate = startDate + " 23:59:59";
		AppParam queryParam = new AppParam();
		queryParam.setService(serviceName);
		queryParam.setMethod("queryPushData");
		queryParam.setRmiServiceName(AppProperties.getProperties(DuoduoConstant.RMI_SERVICE_START + ServiceKey.Key_busi_in));
		queryParam.addAttr("startCreateDate", startDate);
		queryParam.addAttr("endCreateDate", endDate);
		queryParam.addAttr("immediate", 3);
		queryParam.addAttr("size", size);
		AppResult queryResult = RemoteInvoke.getInstance().callNoTx(queryParam);
		for (Map<String, Object> data : queryResult.getRows()) {
			Integer pushType = NumberUtil.getInt(data.get("pushType"), -1);
			PushUtil push = PushList.getPushByCode(pushType);
			if (push != null) {
				int status = push.pushData(data, pushType);
				if (status != 1) {
					PushPlatformUtils.delete(data.get("pushId"), PushPlatformUtils.TYPE_LOAN, -1);
				}
			}
		}
	}
	
	
	
	
	private static boolean isStartPushTime (int type) {
		int hour = SysParamsUtil.getIntParamByKey(("pushData_start_time" + type), 8);
		LocalTime time = LocalTime.now();
		int nowHour = time.getHour();
		if (nowHour >= hour) {
			return true;
		}
		return false;
	}
	
	@Override
	public void init(String queueName ,RabbitMqConfig rabbitMqConfig) {
		super.init(queueName,rabbitMqConfig);
	}
	
    public void init() {
		init(queueName,rabbitMqConfig);
	}
	
	@PreDestroy
	public void destroy(){
		reaseResource();
	}
	
}
